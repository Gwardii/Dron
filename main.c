/**
  ******************************************************************************
  * @file    main.c
  * @author  Ac6
  * @version V1.0
  * @date    01-December-2013
  * @brief   Default main function.
  ******************************************************************************
*/


#include <string.h>
#include "stm32l0xx.h"
#include "stm32l0xx_nucleo.h"




//	konfiguracja u¿ytkownika:

uint8_t CHANNELS=10;		//iloœc kana³ów (4 potrzebne do sterownaia)

//	PID configuration:
// Pitch:
uint8_t Pitch_P=1;
uint8_t Pitch_I=1;
uint8_t Pitch_D=1;
//	Roll
uint8_t Roll_P=1;
uint8_t Roll_I=1;
uint8_t Roll_D=1;
//	Yaw
uint8_t Yaw_P=1;
uint8_t Yaw_I=1;
uint8_t Yaw_D=1;




void print(uint16_t x, int8_t nr,uint8_t enter);
void I2C_Start(uint16_t Number_of_Bytes);
void I2C_StartWrite(uint16_t Number_of_Bytes);
void I2C_StartRead(uint16_t Number_of_Bytes);
void gyro_read();
void acc_read();
void tem_read();
void update_motors();
void stabilize();
int failsafe();

// smienne do debugowania:
float test1;
float test2;
float test3;



// global data
#define  Gyro_Acc_Size 7

uint16_t time_counter=0;
uint16_t time_poprzedni=0;
uint16_t time_obecny=0;
uint8_t txDone=1;
uint16_t channels[14];
int32_t gyro_X=0;
int32_t gyro_Y=0;
int32_t gyro_Z=0;
int32_t acc_X;
int32_t acc_Y;
int32_t acc_Z;
uint32_t data;
int16_t Gyro_Acc[Gyro_Acc_Size];

uint16_t motors[4];

uint16_t PWM_M1=1000;
uint16_t PWM_M2=1000;
uint16_t PWM_M3=1000;
uint16_t PWM_M4=1000;

uint16_t Throttle;
int16_t Pitch;
int16_t Roll;
int16_t Yaw;

int16_t pitch_corr;
int16_t roll_corr;
int16_t yaw_corr;
int16_t pitch_err;
int16_t roll_err;
int16_t yaw_err;
int16_t Sum_pitch_err;
int16_t Sum_roll_err;
int16_t Sum_yaw_err;

// TX
volatile uint8_t time[] = "0000  ";
volatile int32_t g_txSize = 0;
volatile int32_t g_txTransmitted = 0;
volatile int8_t dataFlag = 0;
volatile int8_t dataFlag2 = 0;
// RX
#define Ibus_BufSize (32)
volatile int16_t rxBuf[Ibus_BufSize];
volatile int8_t rxFlag=0;
int8_t rxindex=0;


void USART2_IRQHandler(void) {

//ODBIÓR OD RX:

	//	check if interrupt was generated by right flag:
	if (0 != (USART_ISR_RXNE & USART2->ISR)) {
	//	read actual value of I-BUS (flag will be automatically removed):
	uint8_t val=(USART2->RDR);

	//	waiting for header 0x2040:
	if(rxindex==0 && val!=0x20){
	rxindex=0;
	}
	else if(rxindex==1 && val!=0x40){
	rxindex=0;
	}

	//	if whole I-BUS frame of data is read rewrite it to particular channels:
	else if(rxindex==Ibus_BufSize){
	//reset value:
	rxindex=0;
	int8_t high=3;
	int8_t low=2;

	//	rewriting data to channels, each channel made of 2 bytes in order byte(n)byte(n-1):
	for(int8_t i=0;i<CHANNELS;i++){
	channels[i]=(rxBuf[high]<<8)+rxBuf[low];
	high+=2;
	low+=2;
	}
	//	flag for next function:
	dataFlag=1;
	//	block new data
	USART2->CR1 &= ~USART_CR1_RXNEIE;
	}

	// if header is correct save it and wait for next coming data:
	else{
	rxBuf[rxindex]=(int16_t)val;
	rxindex++;
	}
	}

//TRANSMISJA:

	//	check if interrupt was generated by right flag:
	if ((0 != (USART_CR1_TXEIE & USART2->CR1)) && (0 != (USART_ISR_TXE & USART2->ISR))) {
	//	transmit data:
	if ((0 != g_txSize) && (g_txTransmitted < g_txSize)) {
	USART2->TDR = (uint32_t) time[g_txTransmitted];
	g_txTransmitted += 1;
	}
	// if everything is transmitted, unable transmission interrupts and set flag for next functions:
	if (g_txTransmitted == g_txSize) {
	USART2->CR1 &= ~USART_CR1_TXEIE;
	txDone=1;
	}
	}
}


//przerwanie czytaj¹ce PWM nie istotne ale teoretycznie mozna go uzywac zamiast ibusa (IBUS lepszy)
/*
void TIM2_IRQHandler(void) 						// wywo³ywane kiedy wykryta jest zmiana sygan³u
{
	if (0 != (TIM_SR_CC2IF & TIM2->SR)) { 		// check "Capture/compare 1 interrupt flag"

	TIM2->SR &= ~TIM_SR_CC2IF; 					// clear interrupt flag
	time_obecny=TIM2->CNT;

	 if(!((TIM2->CCER) & TIM_CCER_CC2P)) { 		//wznosz¹cy brzeg

		 TIM2->CCER |=TIM_CCER_CC2P;				//zmiana wywolania przerwania wznoszacy na opadajacy   brzeg
	 }

	 else if(((TIM2->CCER) & TIM_CCER_CC2P)){ 			//opadajacy brzeg

		 TIM2->CCER &=~TIM_CCER_CC2P;			//zmiana wywolania przerwania opadajacy na wznoszacy  brzeg
	 }

	 // sprowadzenie do wartosci dodatnich:
		if (time_obecny>time_poprzedni){
			time_counter=time_obecny-time_poprzedni;
		}
		else{
			time_counter=time_poprzedni-time_obecny;
		}

 	 time_poprzedni=time_obecny;
	 dataFlag=1;


	}
}
*/

int main(void)
{
	// ------------- RCC -------------

	// enable HSI:
	RCC->CR |= RCC_CR_HSION;
	while (0 == (RCC->CR  & RCC_CR_HSIRDY)) {
	// waiting until RDY bit is set
	}
	// set SYSCLK to HSI16:
	RCC->CFGR |= RCC_CFGR_SW_0;

	// ------------- USART2 -------------

	// enable USART2 clock:
	RCC->APB1ENR |= RCC_APB1ENR_USART2EN;
	USART2->BRR = 139 - 1; // 16 000 000 / 115 200 = 138.88
	USART2->CR3 = USART_CR3_OVRDIS;
	USART2->CR1 |= USART_CR1_RXNEIE | USART_CR1_RE | USART_CR1_TE | USART_CR1_UE;
	USART2->ISR=USART_ISR_ORE;

	// ------------- GPIOA (pin 0 - TIM2_CH1, pin 1 - TIM2_CH2, pin 2 - TX, pin 15 - RX) -------------

	// enable GPIOA clock:
	RCC->IOPENR |= RCC_IOPENR_GPIOAEN;

	//	set mode (alternate function):
	GPIOA->MODER &= ~( GPIO_MODER_MODE0_1 | GPIO_MODER_MODE0_0);
	GPIOA->MODER |= ( GPIO_MODER_MODE0_1);

	GPIOA->MODER &= ~( GPIO_MODER_MODE1_1 | GPIO_MODER_MODE1_0);
	GPIOA->MODER |= ( GPIO_MODER_MODE1_1);

	GPIOA->MODER &= ~( GPIO_MODER_MODE2_1 | GPIO_MODER_MODE2_0);
	GPIOA->MODER |= ( GPIO_MODER_MODE2_1);

	GPIOA->MODER &= ~(GPIO_MODER_MODE15_1 | GPIO_MODER_MODE15_0);
	GPIOA->MODER |= (GPIO_MODER_MODE15_1 );

	//	set alternate functions:
	GPIOA->AFR[0] &= ~0x00000FFF;
	GPIOA->AFR[0] |=  0x00000422;
	GPIOA->AFR[1] &= ~0xF0000000;
	GPIOA->AFR[1] |=  0x40000000;

	GPIOA->OSPEEDR |= ( GPIO_OSPEEDER_OSPEED2_1 | GPIO_OSPEEDER_OSPEED2_0 | GPIO_OSPEEDER_OSPEED1_1 | GPIO_OSPEEDER_OSPEED1_0 | GPIO_OSPEEDER_OSPEED15_1 | GPIO_OSPEEDER_OSPEED15_0);

	// ------------- GPIOB (pin 8 - SCL, pin 9 - SDA, pin 10 - TIM2_CH3, pin 11 - TIM2_CH4) -------------

	// enable GPIOB clock:
	RCC->IOPENR |=RCC_IOPENR_GPIOBEN;

	//	set mode (alternate function):
	GPIOB->MODER &= ~( GPIO_MODER_MODE8_1 | GPIO_MODER_MODE8_0);
	GPIOB->MODER |= ( GPIO_MODER_MODE8_1);

	GPIOB->MODER &= ~(GPIO_MODER_MODE9_1 | GPIO_MODER_MODE9_0);
	GPIOB->MODER |= (GPIO_MODER_MODE9_1 );

	GPIOB->MODER &= ~(GPIO_MODER_MODE10_1 | GPIO_MODER_MODE10_0);
	GPIOB->MODER |= (GPIO_MODER_MODE10_1 );

	GPIOB->MODER &= ~(GPIO_MODER_MODE11_1 | GPIO_MODER_MODE11_0);
	GPIOB->MODER |= (GPIO_MODER_MODE11_1 );

	//	set alternate functions:
	GPIOB->AFR[1] &= ~0x0000FFFF;
	GPIOB->AFR[1] |=  0x00002244;

	// Output open-drain (pin 8,9):
	GPIOB->OTYPER |=(GPIO_OTYPER_OT_8|GPIO_OTYPER_OT_9);

	// No pull-up No pull-down
	GPIOB->PUPDR &=~(GPIO_PUPDR_PUPD8_0|GPIO_PUPDR_PUPD8_1|GPIO_PUPDR_PUPD9_0|GPIO_PUPDR_PUPD9_1);

	GPIOB->OSPEEDR |= ( GPIO_OSPEEDER_OSPEED8_1 | GPIO_OSPEEDER_OSPEED8_0 | GPIO_OSPEEDER_OSPEED9_1 | GPIO_OSPEEDER_OSPEED9_0 | GPIO_OSPEEDER_OSPEED10_1 | GPIO_OSPEEDER_OSPEED10_0 | GPIO_OSPEEDER_OSPEED11_1 | GPIO_OSPEEDER_OSPEED11_0);

	//------------- TIM2 ---------------------

	// enable TIM2 clock:
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
	// register is buffered:
	TIM2->CR1 |=TIM_CR1_ARPE;
	// PWM mode 1 and output compare 1 preload enable:
	TIM2->CCMR1 |=TIM_CCMR1_OC1M_1|TIM_CCMR1_OC1M_2|TIM_CCMR1_OC1PE;
	// PWM mode 1 and output compare 2 preload enable:
	TIM2->CCMR1 |=TIM_CCMR1_OC2M_1|TIM_CCMR1_OC2M_2|TIM_CCMR1_OC2PE;
	// PWM mode 1 and output compare 3 preload enable:
	TIM2->CCMR2 |=TIM_CCMR2_OC3M_1|TIM_CCMR2_OC3M_2|TIM_CCMR2_OC3PE;
	// PWM mode 1 and output compare 4 preload enable:
	TIM2->CCMR2 |=TIM_CCMR2_OC4M_1|TIM_CCMR2_OC4M_2|TIM_CCMR2_OC4PE;

	//channel 1 enable:
	TIM2->CCER |=TIM_CCER_CC1E;
	//channel 2 enable:
	TIM2->CCER |=TIM_CCER_CC2E;
	//channel 3 enable:
	TIM2->CCER |=TIM_CCER_CC3E;
	//channel 4 enable:
	TIM2->CCER |=TIM_CCER_CC4E;


	TIM2->PSC = 16-1; 			// zeby counter liczy³ mikrosekundy
	TIM2->ARR = 20000 - 1; 		// 1 okres pwm trwa 20[ms]

	TIM2->CCR1 =1000 - 1; 			//wype³neinie channel 1
	TIM2->CCR2 =1000 - 1; 			//wype³neinie channel 2
	TIM2->CCR3 =1000 - 1; 			//wype³neinie channel 3
	TIM2->CCR4 =1000 - 1; 			//wype³neinie channel 4

	//--------------I2C------------------

	//	enable I2C clock:
	RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;
	//	I2C1 clock source selection (HSI16):
	RCC->CCIPR |=RCC_CCIPR_I2C1SEL_1;
	//	400Hz times setting:
	I2C1->TIMINGR = (uint32_t)0x10320309;
	//	peripheral enable:
	I2C1->CR1 = I2C_CR1_PE;

	//-------main MPU6050 setting-----------

	//	slave address shifted by 1:
	I2C1->CR2 |= 0x68<<1;
	//	start communication:
	I2C_StartWrite(2);
	// address of Power Management 1 register:
	I2C1->TXDR=0x6B;
	while(!(I2C1->ISR & I2C_ISR_TXE)){
	//	waiting as Data will be sent
	}
	// set 0x0 in this register (SLEEP -> 0)
	I2C1->TXDR=0x0;
	while(!(I2C1->ISR & I2C_ISR_TXE)){
	//	waiting as Data will be sent
	}
	//	setting STOP in CR2:
	I2C1->CR2 |=I2C_CR2_STOP;
	while(I2C1->CR2 & I2C_CR2_STOP){
	// 	waiting as STOP byte will be sent
	}

	//---------setting Gyro--------

	//start communication:
	I2C_StartWrite(2);
	// address of Gyroscope Configuration register:
	I2C1->TXDR=0x1C;
	while(!(I2C1->ISR & I2C_ISR_TXE)){
	//	waiting as Data will be sent
	}
	// set +/-1000[deg/s]
	I2C1->TXDR=0x10;
	while(!(I2C1->ISR & I2C_ISR_TXE)){
	//	waiting as Data will be sent
	}
	//	setting STOP in CR2:
	I2C1->CR2 |=I2C_CR2_STOP;
	while(I2C1->CR2 & I2C_CR2_STOP){
	// 	waiting as STOP byte will be sent
	}

	//---------setting Accelerometer-----------

	//	start communication:
	I2C_StartWrite(2);
	//	address of Accelerometer Configuration register:
	I2C1->TXDR=0x1B;
	while(!(I2C1->ISR & I2C_ISR_TXE)){
	//	waiting as Data will be sent
	}
	// set +/-8[g]
	I2C1->TXDR=0x10;
	while(!(I2C1->ISR & I2C_ISR_TXE)){
	//	waiting as Data will be sent
	}
	//	setting STOP in CR2:
	I2C1->CR2 |=I2C_CR2_STOP;
	while(I2C1->CR2 & I2C_CR2_STOP){
	// 	waiting as STOP byte will be sent
	}


	// ------------- NVIC -------------

	// nvic interrupt enable (USART2 interrupt):
	NVIC_EnableIRQ(USART2_IRQn);
	// nvic interrupt enable (TIM2 interrupt):
	NVIC_EnableIRQ(TIM2_IRQn);

	//	TIM2 enabling:
	TIM2->CR1 |=TIM_CR1_CEN;

	int8_t channel_nr=0;
	int8_t gyro_nr=0;





	while (1) {

		gyro_read();
		acc_read();
		tem_read();

		// if failsafe occurs set motors to 0 rpm:

		if(failsafe()){
			PWM_M1=1000;
			PWM_M2=1000;
			PWM_M3=1000;
			PWM_M4=1000;

			update_motors();
		}
		else{
		stabilize();
		update_motors();
		}

		if ((0!=dataFlag)&&(txDone!=0)) {
				// Transmit data

				print(channels[channel_nr],channel_nr,CHANNELS);

				channel_nr++;

				if(channel_nr>=CHANNELS){
					channel_nr=0;
					dataFlag=0;
					USART2->CR1 |= USART_CR1_RXNEIE;	//w³aczam przerwania od odbioru
				}
		}
		//	wypisywanie gyro
		if ((0!=dataFlag2)&&(txDone!=0)){

		print((uint16_t)Gyro_Acc[gyro_nr],gyro_nr,Gyro_Acc_Size);

		gyro_nr++;
		if(gyro_nr>=Gyro_Acc_Size){
			gyro_nr=0;
			dataFlag=0;
			USART2->CR1 |= USART_CR1_RXNEIE;	//w³aczam przerwania od odbioru
		}
		}

		}
	}

void print(uint16_t x, int8_t nr,uint8_t enter){

					time[0] = '0' + (x % 10000) / 1000; //tysi¹ce
					time[1] = '0' + (x % 1000)/100;		//setki
					time[2] = '0' + (x % 100)/10;		//dziesi
					time[3] = '0' + (x % 10);			//jednosci
					if(nr==enter-1){
					time[4] = '\r';
					time[5] = '\n';
					}
					else{
						time[4]=' ';
						time[5]=' ';
					}

					g_txSize = strlen((const char *) time);
					g_txTransmitted = 0;
					txDone=0;
					USART2->CR1 |= USART_CR1_TXEIE;
}

void I2C_Start(uint16_t Number_of_Bytes){
	// Ile bajtów bêdzie wysy³ane:
	I2C1->CR2 = ((~0xF0000 & (I2C1->CR2)) | Number_of_Bytes << 16);
	// wys³anie bajtu START aby rozpocz¹c komunikacje:
	I2C1->CR2 |=I2C_CR2_START;
	while(I2C1->CR2 & I2C_CR2_START){
	// czekam az START w CR2 zosatnie wyczyszczony aby wys³ac kolejne bajty
	}
}

void I2C_StartWrite(uint16_t Number_of_Bytes){
	// transfer direction 0-write 1-read:
	I2C1->CR2 &=~I2C_CR2_RD_WRN;
	// inicjalizacja komunikacji:
	I2C_Start(Number_of_Bytes);
	}

void I2C_StartRead(uint16_t Number_of_Bytes){
	// transfer direction 0-write 1-read
	I2C1->CR2 |=I2C_CR2_RD_WRN;
	// inicjalizacja komunikacji:
	I2C_Start(Number_of_Bytes);
}

void gyro_read(){

	// start communication:
	I2C_StartWrite(1);
	// 1st address of gyroscope measurements register, every next reading will increase register number by 1
	I2C1->TXDR=0x43;
	while(!(I2C1->ISR & I2C_ISR_TXE)){
	//	waiting as Data will be sent
	}

	// How many following register I want read:
	I2C_StartRead(6);

	// First and second registers reads as X:

	while(!(I2C1->ISR & I2C_ISR_RXNE)){
	// waiting as Data arrive to RXDR
	}
	// reading 1st register as upper part of 16-bits Gyro value:
	Gyro_Acc[0] = (I2C1->RXDR <<8);

	while(!(I2C1->ISR & I2C_ISR_RXNE)){
	// waiting as Data arrive to RXDR
	}
	//	reading 2nd register as lower part of 16-bits Gyro value:
	Gyro_Acc[0] |= I2C1->RXDR;

	// 3th and 4th registers reads as Y:

	while(!(I2C1->ISR & I2C_ISR_RXNE)){
	//	waiting as Data arrive to RXDR
	}
	Gyro_Acc[1] = (I2C1->RXDR <<8);	//zapis danych do zmiennej
	while(!(I2C1->ISR & I2C_ISR_RXNE)){
	//	waiting as Data arrive to RXDR
	}
	//	reading 4th register as lower part of 16-bits Gyro value:
	Gyro_Acc[1] |= I2C1->RXDR;

	// 5th and 6th registers reads as Z:

	while(!(I2C1->ISR & I2C_ISR_RXNE)){
	//	waiting as Data arrive to RXDR
	}
	//	reading 5th register as lower part of 16-bits Gyro value:
	Gyro_Acc[2] = (I2C1->RXDR <<8);
	while(!(I2C1->ISR & I2C_ISR_RXNE)){
	//	waiting as Data arrive to RXDR
	}
	//	reading 6th register as lower part of 16-bits Gyro value:
	Gyro_Acc[2] |= I2C1->RXDR;

	//	setting STOP in CR2:
	I2C1->CR2 |=I2C_CR2_STOP;
	while(I2C1->CR2 & I2C_CR2_STOP){
	// 	waiting as STOP byte will be sent
	}
	//	rescale data from register to format 0-2000 (represent -1000 - 1000 [deg/s] in real)
	Gyro_Acc[0]=Gyro_Acc[0]/32768.*1000+1000;
	Gyro_Acc[1]=Gyro_Acc[1]/32768.*1000+1000;
	Gyro_Acc[2]=Gyro_Acc[2]/32768.*1000+1000;
	dataFlag2=1;

}

void acc_read(){
	//	start communication:
	I2C_StartWrite(1);

	//	1st address of accelerometer measurements, every next reading will increase register number by 1
	I2C1->TXDR=0x3B;
	while(!(I2C1->ISR & I2C_ISR_TXE)){
	//	waiting as Data will be sent
	}
	// How many following register I want read:
	I2C_StartRead(6);

	// First and second registers reads as X:

	while(!(I2C1->ISR & I2C_ISR_RXNE)){
	//	waiting as Data arrive to RXDR
	}
	//	reading 1st register as upper part of 16-bits Acc value:
	Gyro_Acc[3] = (I2C1->RXDR <<8);
	while(!(I2C1->ISR & I2C_ISR_RXNE)){
	//	waiting as Data arrive to RXDR
	}
	//	reading 2nd register as lower part of 16-bits Acc value:
	Gyro_Acc[3] |= I2C1->RXDR;

	// First and second registers reads as Y:

	while(!(I2C1->ISR & I2C_ISR_RXNE)){
	//	waiting as Data arrive to RXDR
	}
	//	reading 3th register as upper part of 16-bits Acc value:
	Gyro_Acc[4] = (I2C1->RXDR <<8);
	while(!(I2C1->ISR & I2C_ISR_RXNE)){
	//	waiting as Data arrive to RXDR
	}
	//	reading 4th register as lower part of 16-bits Acc value:
	Gyro_Acc[4] |= I2C1->RXDR;

	// First and second registers reads as Z:

	while(!(I2C1->ISR & I2C_ISR_RXNE)){
	//	waiting as Data arrive to RXDR
	}
	//	reading 5th register as upper part of 16-bits Acc value:
	Gyro_Acc[5] = (I2C1->RXDR <<8);
	while(!(I2C1->ISR & I2C_ISR_RXNE)){
	//	waiting as Data arrive to RXDR
	}
	//	reading 6th register as lower part of 16-bits Acc value:
	Gyro_Acc[5] |= I2C1->RXDR;

	//	setting STOP in CR2:
	I2C1->CR2 |=I2C_CR2_STOP;
	while(I2C1->CR2 & I2C_CR2_STOP){
	// 	waiting as STOP byte will be sent
	}

test1=(float)Gyro_Acc[3]/4096;
test2=(float)Gyro_Acc[4]/4096;
test3=(float)Gyro_Acc[5]/4096;
	//	rescale data from register to format 0-1600 (represent -8.00 - 8.00 [g] in real)
	Gyro_Acc[3]=Gyro_Acc[3]*100/4096+800;
	Gyro_Acc[4]=Gyro_Acc[4]*100/4096+800;
	Gyro_Acc[5]=Gyro_Acc[5]*100/4096+800;

	dataFlag2=1;

}

void tem_read(){
	//start communication:
	I2C_StartWrite(1);

	//1st address of thermometer measurements, every next reading will increase register number by 1
	I2C1->TXDR=0x41;
	while(!(I2C1->ISR & I2C_ISR_TXE)){
	//	waiting as Data will be sent
	}
	//	How many following register I want read:
	I2C_StartRead(2);

	// First and second registers reads as T:

	while(!(I2C1->ISR & I2C_ISR_RXNE)){
	//	waiting as Data arrive to RXDR
	}
	//	reading 1st register as upper part of 16-bits Acc value:
	Gyro_Acc[6] = (I2C1->RXDR <<8);
	while(!(I2C1->ISR & I2C_ISR_RXNE)){
	//	waiting as Data arrive to RXDR
	}
	//	reading 2nd register as lower part of 16-bits Acc value:
	Gyro_Acc[6] |= I2C1->RXDR;

	//	setting STOP in CR2:
	I2C1->CR2 |=I2C_CR2_STOP;
	while(I2C1->CR2 & I2C_CR2_STOP){
	// 	waiting as STOP byte will be sent
	}

	//	normalizing temperature value (but multiply by 100)
	Gyro_Acc[6]=Gyro_Acc[6]*100/340+3653;

	dataFlag2=1;

}

void update_motors(){
		TIM2->CCR1 =PWM_M1 - 1; 			//wype³neinie motor 1
		TIM2->CCR2 =PWM_M2 - 1; 			//wype³neinie motor 2
		TIM2->CCR3 =PWM_M3 - 1; 			//wype³neinie motor 3
		TIM2->CCR4 =PWM_M4 - 1; 			//wype³neinie motor 4

}

void stabilize (){

	// err values - difference between set value and measured value:
	pitch_err=channels[1]-Pitch;
	roll_err=channels[0]-Roll;
	yaw_err=channels[3]-Yaw;

	//	estimate Integral by sum (I term):
	Sum_pitch_err += pitch_err;
	Sum_roll_err +=	 roll_err;
	Sum_yaw_err += yaw_err;

	//	calculate corrections:
	pitch_corr= Pitch_P*pitch_err+Pitch_I*Sum_pitch_err;
	roll_corr= Roll_P*roll_err+Roll_I*Sum_roll_err;
	yaw_corr= Yaw_P*yaw_err+Yaw_I*Sum_yaw_err;

	//	right front:
	PWM_M1=Throttle-pitch_corr+yaw_corr+roll_corr;
	//	right back:
	PWM_M2=Throttle+pitch_corr-yaw_corr+roll_corr;
	//	left back:
	PWM_M3=Throttle-pitch_corr+yaw_corr-roll_corr;
	//	left front:
	PWM_M4=Throttle+pitch_corr-yaw_corr-roll_corr;

}
int failsafe(){
	// Arming switch - SA
	if(channels[4]>=1300){
	return(1);
	}
	// if failsafe not appears:
	else{
	return(0);
	}
}
