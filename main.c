/**
  ******************************************************************************
  * @file    main.c
  * @author  Ac6
  * @version V1.0
  * @date    01-December-2013
  * @brief   Default main function.
  ******************************************************************************
*/


#include "stm32l0xx.h"
#include "stm32l0xx_nucleo.h"
#include "setup.h"
#include "MPU6050.h"


//	konfiguracja uzytkownika:

uint8_t CHANNELS=10;		//ilosc kanalów (4 potrzebne do sterownaia)

//	PID configuration:
// Pitch:
uint8_t Pitch_P=1;
uint8_t Pitch_I=1;
uint8_t Pitch_D=1;
//	Roll
uint8_t Roll_P=1;
uint8_t Roll_I=1;
uint8_t Roll_D=1;
//	Yaw
uint8_t Yaw_P=1;
uint8_t Yaw_I=1;
uint8_t Yaw_D=1;




void print(uint16_t x, int8_t nr,uint8_t enter);
void update_motors();
void stabilize();
int failsafe();

// zmienne do debugowania:
float test1;
float test2;
float test3;



// global data
#define  Gyro_Acc_Size 7

uint16_t time_counter=0;
uint16_t time_poprzedni=0;
uint16_t time_obecny=0;
uint8_t txDone=1;
uint16_t channels[14];
int32_t gyro_X=0;
int32_t gyro_Y=0;
int32_t gyro_Z=0;
int32_t acc_X;
int32_t acc_Y;
int32_t acc_Z;
uint32_t data;
int16_t Gyro_Acc[Gyro_Acc_Size];

uint16_t motors[4];

uint16_t PWM_M1=1000;
uint16_t PWM_M2=1000;
uint16_t PWM_M3=1000;
uint16_t PWM_M4=1000;

uint16_t Throttle;
int16_t Pitch;
int16_t Roll;
int16_t Yaw;

int16_t pitch_corr;
int16_t roll_corr;
int16_t yaw_corr;
int16_t pitch_err;
int16_t roll_err;
int16_t yaw_err;
int16_t Sum_pitch_err;
int16_t Sum_roll_err;
int16_t Sum_yaw_err;

// TX
volatile uint8_t time[] = "0000  ";
volatile int32_t g_txSize = 0;
volatile int32_t g_txTransmitted = 0;
volatile int8_t dataFlag = 0;
volatile int8_t dataFlag2 = 0;
// RX
#define Ibus_BufSize (32)
volatile int16_t rxBuf[Ibus_BufSize];
volatile int8_t rxFlag=0;
int8_t rxindex=0;


void USART2_IRQHandler(void) {

//ODBIÓR OD RX:

	//	check if interrupt was generated by right flag:
	if (0 != (USART_ISR_RXNE & USART2->ISR)) {
	//	read actual value of I-BUS (flag will be automatically removed):
	uint8_t val=(USART2->RDR);

	//	waiting for header 0x2040:
	if(rxindex==0 && val!=0x20){
	rxindex=0;
	}
	else if(rxindex==1 && val!=0x40){
	rxindex=0;
	}

	//	if whole I-BUS frame of data is read rewrite it to particular channels:
	else if(rxindex==Ibus_BufSize){
	//reset value:
	rxindex=0;
	int8_t high=3;
	int8_t low=2;

	//	rewriting data to channels, each channel made of 2 bytes in order byte(n)byte(n-1):
	for(int8_t i=0;i<CHANNELS;i++){
	channels[i]=(rxBuf[high]<<8)+rxBuf[low];
	high+=2;
	low+=2;
	}
	//	flag for next function:
	dataFlag=1;
	//	block new data
	USART2->CR1 &= ~USART_CR1_RXNEIE;
	}

	// if header is correct save it and wait for next coming data:
	else{
	rxBuf[rxindex]=(int16_t)val;
	rxindex++;
	}
	}

//TRANSMISJA:

	//	check if interrupt was generated by right flag:
	if ((0 != (USART_CR1_TXEIE & USART2->CR1)) && (0 != (USART_ISR_TXE & USART2->ISR))) {
	//	transmit data:
	if ((0 != g_txSize) && (g_txTransmitted < g_txSize)) {
	USART2->TDR = (uint32_t) time[g_txTransmitted];
	g_txTransmitted += 1;
	}
	// if everything is transmitted, unable transmission interrupts and set flag for next functions:
	if (g_txTransmitted == g_txSize) {
	USART2->CR1 &= ~USART_CR1_TXEIE;
	txDone=1;
	}
	}
}


//przerwanie czytajace PWM nie istotne ale teoretycznie mozna go uzywac zamiast ibusa (IBUS lepszy)
/*
void TIM2_IRQHandler(void) 						// wywolywane kiedy wykryta jest zmiana syganlu
{
	if (0 != (TIM_SR_CC2IF & TIM2->SR)) { 		// check "Capture/compare 1 interrupt flag"
	TIM2->SR &= ~TIM_SR_CC2IF; 					// clear interrupt flag
	time_obecny=TIM2->CNT;
	 if(!((TIM2->CCER) & TIM_CCER_CC2P)) { 		//wznoszacy brzeg
		 TIM2->CCER |=TIM_CCER_CC2P;				//zmiana wywolania przerwania wznoszacy na opadajacy   brzeg
	 }
	 else if(((TIM2->CCER) & TIM_CCER_CC2P)){ 			//opadajacy brzeg
		 TIM2->CCER &=~TIM_CCER_CC2P;			//zmiana wywolania przerwania opadajacy na wznoszacy  brzeg
	 }
	 // sprowadzenie do wartosci dodatnich:
		if (time_obecny>time_poprzedni){
			time_counter=time_obecny-time_poprzedni;
		}
		else{
			time_counter=time_poprzedni-time_obecny;
		}
 	 time_poprzedni=time_obecny;
	 dataFlag=1;
	}
}
*/

int main(void)
{
	setup();
	setup_MPU6050();

	int8_t channel_nr=0;
	int8_t gyro_nr=0;

	while (1) {

		gyro_read();
		acc_read();
		tem_read();

		// if failsafe occurs set motors to 0 rpm:

		if(failsafe()){
			PWM_M1=1000;
			PWM_M2=1000;
			PWM_M3=1000;
			PWM_M4=1000;

			update_motors();
		}
		else{
		stabilize();
		update_motors();
		}

		if ((0!=dataFlag)&&(txDone!=0)) {
				// Transmit data

				print(channels[channel_nr],channel_nr,CHANNELS);

				channel_nr++;

				if(channel_nr>=CHANNELS){
					channel_nr=0;
					dataFlag=0;
					USART2->CR1 |= USART_CR1_RXNEIE;	//wlaczam przerwania od odbioru
				}
		}
		//	wypisywanie gyro
		if ((0!=dataFlag2)&&(txDone!=0)){

		print((uint16_t)Gyro_Acc[gyro_nr],gyro_nr,Gyro_Acc_Size);

		gyro_nr++;
		if(gyro_nr>=Gyro_Acc_Size){
			gyro_nr=0;
			dataFlag=0;
			USART2->CR1 |= USART_CR1_RXNEIE;	//wlaczam przerwania od odbioru
		}
		}

		}
	}

void print(uint16_t x, int8_t nr,uint8_t enter){

					time[0] = '0' + (x % 10000) / 1000; //tysiace
					time[1] = '0' + (x % 1000)/100;		//setki
					time[2] = '0' + (x % 100)/10;		//dziesi
					time[3] = '0' + (x % 10);			//jednosci
					if(nr==enter-1){
					time[4] = '\r';
					time[5] = '\n';
					}
					else{
						time[4]=' ';
						time[5]=' ';
					}

					g_txSize = 6;//strlen((const char *) time);
					g_txTransmitted = 0;
					txDone=0;
					USART2->CR1 |= USART_CR1_TXEIE;
}






void update_motors(){
		TIM2->CCR1 =PWM_M1 - 1; 			//wypelneinie motor 1
		TIM2->CCR2 =PWM_M2 - 1; 			//wypelneinie motor 2
		TIM2->CCR3 =PWM_M3 - 1; 			//wypelneinie motor 3
		TIM2->CCR4 =PWM_M4 - 1; 			//wypelneinie motor 4

}

void stabilize (){

	// err values - difference between set value and measured value:
	pitch_err=channels[1]-Pitch;
	roll_err=channels[0]-Roll;
	yaw_err=channels[3]-Yaw;

	//	estimate Integral by sum (I term):
	Sum_pitch_err += pitch_err;
	Sum_roll_err +=	 roll_err;
	Sum_yaw_err += yaw_err;

	//	calculate corrections:
	pitch_corr= Pitch_P*pitch_err+Pitch_I*Sum_pitch_err;
	roll_corr= Roll_P*roll_err+Roll_I*Sum_roll_err;
	yaw_corr= Yaw_P*yaw_err+Yaw_I*Sum_yaw_err;

	//	right front:
	PWM_M1=Throttle-pitch_corr+yaw_corr+roll_corr;
	//	right back:
	PWM_M2=Throttle+pitch_corr-yaw_corr+roll_corr;
	//	left back:
	PWM_M3=Throttle-pitch_corr+yaw_corr-roll_corr;
	//	left front:
	PWM_M4=Throttle+pitch_corr-yaw_corr-roll_corr;

}
int failsafe(){
	// Arming switch - SA
	if(channels[4]>=1300){
	return(1);
	}
	// if failsafe not appears:
	else{
	return(0);
	}
}
