/**
  ******************************************************************************
  * @file    main.c
  * @author  Ac6
  * @version V1.0
  * @date    01-December-2013
  * @brief   Default main function.
  ******************************************************************************
*/


#include "stm32l0xx.h"
#include "stm32l0xx_nucleo.h"
#include "setup.h"
#include "MPU6050.h"
#include "stabilize.h"



//	konfiguracja uzytkownika:

uint8_t CHANNELS=10;		//ilosc kanalĂłw (4 potrzebne do sterownaia)




void print(uint16_t x, int8_t nr,uint8_t enter);
void update_motors();
int failsafe();
void LED ();

// zmienne do debugowania:
float test1;
float test2;
float test3;



// global data
#define  Gyro_Acc_Size 7

uint16_t current_time=0;
uint16_t last_time=0;
uint16_t gap_time=0;
uint8_t txDone=1;
uint16_t channels[14];
int32_t gyro_X=0;
int32_t gyro_Y=0;
int32_t gyro_Z=0;
int32_t acc_X;
int32_t acc_Y;
int32_t acc_Z;
uint32_t data;
int16_t Gyro_Acc[Gyro_Acc_Size];

uint16_t motors[4];

uint16_t PWM_M1=1000;
uint16_t PWM_M2=1000;
uint16_t PWM_M3=1000;
uint16_t PWM_M4=1000;

uint16_t Throttle;
int16_t Pitch;
int16_t Roll;
int16_t Yaw;



// TX
volatile uint8_t time[] = "0000  ";
volatile int32_t g_txSize = 0;
volatile int32_t g_txTransmitted = 0;
volatile int8_t dataFlag = 0;
volatile int8_t dataFlag2 = 0;
// RX
////#define Ibus_BufSize (32)
////volatile int16_t rxBuf[Ibus_BufSize];
//volatile int8_t rxFlag=0;
//int8_t rxindex=0;
volatile uint8_t rxBuf[32];
volatile uint8_t rxindex=0;
volatile int8_t ibus_received=0;

void USART2_IRQHandler(void) {

	//ODBIOR OD RX:

	//	check if interrupt was generated by right flag:
	if (0 != (USART_ISR_RXNE & USART2->ISR)) {
	//	read actual value of I-BUS (flag will be automatically removed):
	rxBuf[rxindex]=USART2->RDR;

	current_time=TIM2->CNT;
	if(current_time<last_time){
		gap_time=current_time-last_time+TIM2->ARR;
	}else{
	gap_time=current_time-last_time;
	}
	last_time=current_time;
	if (gap_time>500){
		rxindex=0;
	}

	if(rxindex==31){
	ibus_received=1;
	//block receiving new data until old data are processed:
	USART2->CR1 &= ~USART_CR1_RXNEIE;

	}	//	waiting for header 0x2040:
	else if(rxindex==0 && rxBuf[rxindex]!=0x20){
		rxindex=0;
	}else if(rxindex==1 && rxBuf[rxindex]!=0x40){
		rxindex=0;
	}else{	//if header is right increase rxindex
		rxindex++;
		}
	}

//TRANSMISJA:

	//	check if interrupt was generated by right flag:
	if ((0 != (USART_CR1_TXEIE & USART2->CR1)) && (0 != (USART_ISR_TXE & USART2->ISR))) {
	//	transmit data:
	if ((0 != g_txSize) && (g_txTransmitted < g_txSize)) {
	USART2->TDR = (uint32_t) time[g_txTransmitted];
	g_txTransmitted += 1;
	}
	// if everything is transmitted, unable transmission interrupts:
	if (g_txTransmitted == g_txSize) {
	USART2->CR1 &= ~USART_CR1_TXEIE;
	}
	}
}


//przerwanie czytajace PWM nie istotne ale teoretycznie mozna go uzywac zamiast ibusa (IBUS lepszy)
/*
void TIM2_IRQHandler(void) 						// wywolywane kiedy wykryta jest zmiana syganlu
{
	if (0 != (TIM_SR_CC2IF & TIM2->SR)) { 		// check "Capture/compare 1 interrupt flag"
	TIM2->SR &= ~TIM_SR_CC2IF; 					// clear interrupt flag
	time_obecny=TIM2->CNT;
	 if(!((TIM2->CCER) & TIM_CCER_CC2P)) { 		//wznoszacy brzeg
		 TIM2->CCER |=TIM_CCER_CC2P;				//zmiana wywolania przerwania wznoszacy na opadajacy   brzeg
	 }
	 else if(((TIM2->CCER) & TIM_CCER_CC2P)){ 			//opadajacy brzeg
		 TIM2->CCER &=~TIM_CCER_CC2P;			//zmiana wywolania przerwania opadajacy na wznoszacy  brzeg
	 }
	 // sprowadzenie do wartosci dodatnich:
		if (time_obecny>time_poprzedni){
			time_counter=time_obecny-time_poprzedni;
		}
		else{
			time_counter=time_poprzedni-time_obecny;
		}
 	 time_poprzedni=time_obecny;
	 dataFlag=1;
	}
}
*/

int main(void)
{
	setup();
	setup_MPU6050();

	int8_t channel_nr=0;
	int8_t gyro_nr=0;
	int8_t new_I_Bus=0;
	while (1) {

	// checking checksum and rewriting rxBuf to channels:
		if(ibus_received){
			uint16_t checksum=0xFFFF;
			for(int8_t i=0;i<30;i++){
			checksum -=rxBuf[i];
			}if(checksum==((rxBuf[31]<<8)+rxBuf[30])){
				for(int8_t i=0;i<CHANNELS;i++){
					channels[i]=(rxBuf[2*(i+1)+1]<<8)+rxBuf[2*(i+1)];
					}
				new_I_Bus=1;
				rxindex=0;
			}else{//checksum is not correct
			}
		//	unlock receiving data from i-Bus:
			USART2->CR1 |= USART_CR1_RXNEIE;
			ibus_received=0;
			rxindex=0;
		}



		Throttle=channels[2];
		// if failsafe occurs set motors to 0 rpm:

		if(failsafe()){
			PWM_M1=1000;
			PWM_M2=1000;
			PWM_M3=1000;
			PWM_M4=1000;

			update_motors();
		}
		else{
//		stabilize();
//		LED();// przeskalowanie pwm zeby ledy imitowaly jasnoscia obroty
//		update_motors();
		}

		if (0!=new_I_Bus) {
				// Transmit data

				print(channels[channel_nr],channel_nr,CHANNELS);

				channel_nr++;

				if(channel_nr>=CHANNELS){
					channel_nr=0;
					dataFlag=0;
					//USART2->CR1 |= USART_CR1_RXNEIE;	//wlaczam przerwania od odbioru
				}
		}

//		//	wypisywanie gyro
//		if ((0!=dataFlag2)&&(txDone!=0)){
//
//		print((uint16_t)Gyro_Acc[gyro_nr],gyro_nr,Gyro_Acc_Size);
//
//		gyro_nr++;
//		if(gyro_nr>=Gyro_Acc_Size){
//			gyro_nr=0;
//			dataFlag=0;
//			USART2->CR1 |= USART_CR1_RXNEIE;	//wlaczam przerwania od odbioru
//		}
//		}

		}
	}

void LED ()
{
	PWM_M1=(PWM_M1-1000)*20000;
	PWM_M2=(PWM_M2-1000)*20000;
	PWM_M3=(PWM_M3-1000)*20000;
	PWM_M4=(PWM_M4-1000)*20000;
}
void print(uint16_t x, int8_t nr,uint8_t enter){

					time[0] = '0' + (x % 10000) / 1000; //tysiace
					time[1] = '0' + (x % 1000)/100;		//setki
					time[2] = '0' + (x % 100)/10;		//dziesi
					time[3] = '0' + (x % 10);			//jednosci
					if(nr==enter-1){
					time[4] = '\r';
					time[5] = '\n';
					}
					else{
						time[4]=' ';
						time[5]=' ';
					}

					g_txSize = 6;//strlen((const char *) time);
					g_txTransmitted = 0;
					txDone=0;
					USART2->CR1 |= USART_CR1_TXEIE;
}






void update_motors(){
		TIM2->CCR1 =PWM_M1 - 1; 			//wypelneinie motor 1
		TIM2->CCR2 =PWM_M2 - 1; 			//wypelneinie motor 2
		TIM2->CCR3 =PWM_M3 - 1; 			//wypelneinie motor 3
		TIM2->CCR4 =PWM_M4 - 1; 			//wypelneinie motor 4

}


int failsafe(){
	// Arming switch - SA
	if(channels[4]<=1600){
	return(1);
	}
	// if failsafe not appears:
	else{
	return(0);
	}
}
